using Microsoft.Extensions.Configuration;
using Microsoft.Identity.Client;
//using Microsoft.Identity.Client.Broker;
using Microsoft.Identity.Client.Extensions.Msal;
using Microsoft.IdentityModel.Abstractions;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using static System.Formats.Asn1.AsnWriter;

namespace MAUI.MSALClient
{
    /// <summary>
    /// Contains methods that initialize and use the MSAL SDK
    /// </summary>
    /// <autogeneratedoc />
    public class MSALClientHelper
    {
        /// <summary>
        /// As for the Tenant, you can use a name as obtained from the azure portal, e.g. kko365.onmicrosoft.com"
        /// </summary>

        public static AzureADConfig AzureADConfig;

        /// <summary>
        /// Gets the authentication result (if available) from MSAL's various operations.
        /// </summary>
        /// <value>
        /// The authentication result.
        /// </value>

        public AuthenticationResult AuthResult { get; private set; }

        /// <summary>
        /// Gets a value indicating whether this instance of PublicClientApp was initialized with a broker .
        /// </summary>
        /// <value>
        ///   <c>true</c> if this instance is broker initialized; otherwise, <c>false</c>.
        /// </value>
        public bool IsBrokerInitialized { get; private set; }

        /// <summary>
        /// Gets the MSAL public client application instance.
        /// </summary>
        /// <value>
        /// The public client application.
        /// </value>
        public IPublicClientApplication PublicClientApplication { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MSALClientHelper"/> class.
        /// </summary>
        public MSALClientHelper(string embeddedConfigFileName = "MauiAppWithBroker.appsettings.json")
        {
            var assembly = Assembly.GetExecutingAssembly();
            using var stream = assembly.GetManifestResourceStream(embeddedConfigFileName);
            IConfiguration AppConfiguration = new ConfigurationBuilder()
                .AddJsonStream(stream)
                .Build();

            //AzureADConfig = AppConfiguration.GetSection("AzureAD").Get<AzureADConfig>();
            LoadConfig(AppConfiguration);
        }

        private void LoadConfig(IConfiguration appConfiguration)
        {
            AzureADConfig = appConfiguration.GetSection("AzureAD").Get<AzureADConfig>();
        }

        /// <summary>
        /// Initializes the public client application of MSAL.NET with the required information to correctly authenticate the user.
        /// </summary>
        /// <returns></returns>

        public async Task<IAccount> InitializePublicClientAppAsync()
        {
            // Initialize the MSAL library by building a public client application
            this.PublicClientApplication = PublicClientApplicationBuilder
                                        .Create(AzureADConfig.ClientId)
                                        .WithAuthority(string.Format(AzureADConfig.Authority, AzureADConfig.TenantId))
                                        .WithExperimentalFeatures() // this is for upcoming logger
                                        .WithLogging(new IdentityLogger(EventLogLevel.Warning), enablePiiLogging: false)    // This is the currently recommended way to log MSAL message. For more info refer to https://github.com/AzureAD/microsoft-authentication-library-for-dotnet/wiki/logging. Set Identity Logging level to Warning which is a middle ground
                                        .WithClientCapabilities(new string[] { "cp1" })                                     // declare this client app capable of receiving CAE events- https://aka.ms/clientcae
                                        .WithRedirectUri(PlatformConfig.Instance.RedirectUri)
                                        .WithIosKeychainSecurityGroup("com.microsoft.adalcache")
                                        .Build();

            await AttachTokenCache();
            return await FetchSignedInUserFromCache().ConfigureAwait(false);
        }

        /// <summary>
        /// Initializes the public client application of MSAL.NET with the required information to correctly authenticate the user.
        /// </summary>
        /// <returns>An IAccount of an already signed-in user (if available)</returns>
        public async Task<IAccount> InitializePublicClientAppForWAMBrokerAsync()
        {
            // Initialize the MSAL library by building a public client application
            this.PublicClientApplication = PublicClientApplicationBuilder
                        .Create(AzureADConfig.ClientId)
                        .WithAuthority(string.Format(AzureADConfig.Authority, AzureADConfig.TenantId))
                        .WithBroker()
                        .WithRedirectUri(PlatformConfig.Instance.RedirectUri)
                        .WithExperimentalFeatures() // this is for upcoming logger
                        .WithLogging(new IdentityLogger(EventLogLevel.Warning), enablePiiLogging: false)                // This is the currently recommended way to log MSAL message. For more info refer to https://github.com/AzureAD/microsoft-authentication-library-for-dotnet/wiki/logging. Set Identity Logging level to Warning which is a middle ground
                        .WithClientCapabilities(new string[] { "cp1" })                                                 // declare this client app capable of receiving CAE events- https://aka.ms/clientcae
                        .WithIosKeychainSecurityGroup("com.microsoft.adalcache")
                        .Build();

            this.IsBrokerInitialized = true;

            await AttachTokenCache();
            return await FetchSignedInUserFromCache().ConfigureAwait(false);
        }

        /// <summary>
        /// Attaches the token cache to the Public Client app.
        /// </summary>
        /// <returns>IAccount list of already signed-in users (if available)</returns>
        public async Task<IEnumerable<IAccount>> AttachTokenCache()
        {
            if (DeviceInfo.Current.Platform != DevicePlatform.WinUI)
            {
                return null;
            }

            // Cache configuration and hook-up to public application. Refer to https://github.com/AzureAD/microsoft-authentication-extensions-for-dotnet/wiki/Cross-platform-Token-Cache#configuring-the-token-cache
            var storageProperties = new StorageCreationPropertiesBuilder(AzureADConfig.CacheFileName, AzureADConfig.CacheDir).Build();
            var msalcachehelper = await MsalCacheHelper.CreateAsync(storageProperties);
            msalcachehelper.RegisterCache(PublicClientApplication.UserTokenCache);

            // If the cache file is being reused, we'd find some already-signed-in accounts 
            return await PublicClientApplication.GetAccountsAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Signs in the user and obtains an Access token for a provided set of scopes
        /// </summary>
        /// <param name="scopes"></param>
        /// <returns> Access Token</returns>
        public async Task<string> SignInUserAndAcquireAccessToken(string[] scopes)
        {
            var existingUser = await FetchSignedInUserFromCache().ConfigureAwait(false);

            try
            {
                this.AuthResult = await this.PublicClientApplication.AcquireTokenSilent(scopes, existingUser)
                    .ExecuteAsync().ConfigureAwait(false);
            }
            catch (MsalUiRequiredException ex)
            {
                // A MsalUiRequiredException happened on AcquireTokenSilentAsync. This indicates you need to call AcquireTokenAsync to acquire a token
                Debug.WriteLine($"MsalUiRequiredException: {ex.Message}");

                // Must be called from UI thread
                if (!IsBrokerInitialized)
                {
                    this.AuthResult = await this.PublicClientApplication.AcquireTokenInteractive(scopes)
                                    .ExecuteAsync()
                                    .ConfigureAwait(false);
                }
                else
                {
                    this.AuthResult = await this.PublicClientApplication.AcquireTokenInteractive(scopes)
                                    .WithParentActivityOrWindow(PlatformConfig.Instance.ParentWindow)   // This is required when using the WAM broker
                                    .ExecuteAsync()
                                    .ConfigureAwait(false);
                }
            }
            catch (MsalException msalEx)
            {
                Debug.WriteLine($"Error Acquiring Token:{Environment.NewLine}{msalEx}");
            }

            return this.AuthResult.AccessToken;
        }

        /// <summary>
        /// Removes the first signed-in user's record from token cache
        /// </summary>
        public async void SignOutUser()
        {
            var existingUser = await FetchSignedInUserFromCache().ConfigureAwait(false);
            this.SignOutUser(existingUser);
        }

        /// <summary>
        /// Removes a given user's record from token cache
        /// </summary>
        /// <param name="user">The user.</param>
        public async void SignOutUser(IAccount user)
        {
            await this.PublicClientApplication.RemoveAsync(user).ConfigureAwait(false);
        }

        /// <summary>
        /// Signs the in user and acquire access token for a provided set of scopes.
        /// </summary>
        /// <param name="scopes">The scopes.</param>
        /// <param name="extraclaims">The extra claims, usually from CAE. We basically handle CAE by sending the user back to Azure AD for additional processing and requesting a new access token for Graph</param>
        /// <returns></returns>
        public async Task<String> SignInUserAndAcquireAccessToken(string[] scopes, string extraclaims)
        {
            var existingUser = await FetchSignedInUserFromCache().ConfigureAwait(false);

            try
            {

                // Send the user to Azure AD for re-authentication as a silent acquisition wont resolve any CAE scenarios like an extra claims request             
                if (!IsBrokerInitialized)
                {
                    this.AuthResult = await this.PublicClientApplication.AcquireTokenInteractive(scopes)
                                    .WithClaims(extraclaims)
                                    .ExecuteAsync()
                                    .ConfigureAwait(false);
                }
                else
                {
                    this.AuthResult = await this.PublicClientApplication.AcquireTokenInteractive(scopes)
                                    .WithClaims(extraclaims)
                                    .WithParentActivityOrWindow(PlatformConfig.Instance.ParentWindow)   // This is required when using the WAM broker
                                    .ExecuteAsync()
                                    .ConfigureAwait(false);
                }
            }
            catch (MsalException msalEx)
            {
                Debug.WriteLine($"Error Acquiring Token:{Environment.NewLine}{msalEx}");
            }

            return this.AuthResult.AccessToken;
        }

        private async Task<AuthenticationResult> LoginSilentAndInteractiveAsync(string[] scopes)
        {
            var existingUser = await FetchSignedInUserFromCache().ConfigureAwait(false);

            try
            {
                // 1. Try to sign-in the previously signed-in account
                if (existingUser != null)
                {
                    Console.WriteLine("Found account in the cache - trying to use it");

                    return await this.PublicClientApplication.AcquireTokenSilent(scopes, existingUser)
                            .ExecuteAsync();
                }
                // 2. If it does not exist, try to sign in with the OS account. Only Windows broker supports this
                else
                {
                    if (this.IsBrokerInitialized)
                    {
                        Console.WriteLine("No accounts found in the cache. Trying Window's default account.");

                        return await this.PublicClientApplication.AcquireTokenSilent(
                            scopes,
                            Microsoft.Identity.Client.PublicClientApplication.OperatingSystemAccount)
                                .ExecuteAsync();
                    }
                }
            }
            catch (MsalUiRequiredException ex)
            {
                Console.WriteLine("Could not acquire a token silently from cache or broker... " + ex);
            }

            // 3. If all else fails, use interactive auth
            return await LoginInteractiveAsync(scopes, existingUser).ConfigureAwait(false);
        }

        private async Task<AuthenticationResult> LoginInteractiveAsync(string[] scopes, IAccount existingAccount = null)
        {
            // If the operating system has UI
            if (this.PublicClientApplication.IsUserInteractive())
            {
                return await this.PublicClientApplication.AcquireTokenInteractive(scopes)
                    .WithLoginHint(existingAccount?.Username ?? String.Empty)
                    // .WithParentActivityOrWindow(WindowsHelper.GetConsoleOrTerminalWindow()) // TODO: fix it
                    .ExecuteAsync()
                    .ConfigureAwait(false);
            }

            // If the operating system does not have UI (e.g. SSH into Linux), you can fallback to device code, however this
            // flow will not satisfy the "device is managed" CA policy.
            return await this.PublicClientApplication.AcquireTokenWithDeviceCode(scopes, (dcr) =>
            {
                Console.WriteLine(dcr.Message);
                return Task.CompletedTask;
            }).ExecuteAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches the signed in user from MSAL's token cache (if available).
        /// </summary>
        /// <returns></returns>
        /// <autogeneratedoc />
        public async Task<IAccount> FetchSignedInUserFromCache()
        {
            // get accounts from cache
            IEnumerable<IAccount> accounts = await this.PublicClientApplication.GetAccountsAsync().ConfigureAwait(false);

            // Error corner case: we should always have 0 or 1 accounts, not expecting > 1
            // This is just an example of how to resolve this ambiguity, which can arise if more apps share a token cache.
            // Note that some apps prefer to use a random account from the cache.
            if (accounts.Count() > 1)
            {
                foreach (var acc in accounts)
                {
                    await this.PublicClientApplication.RemoveAsync(acc);
                }

                return null;
            }

            return accounts.SingleOrDefault();
        }
    }
}